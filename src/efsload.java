import java.io.BufferedReader;import java.io.DataInputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.List;import java.util.Map;/** * @author shengyin *  */public class efsload {    public efsload() throws IOException {        File struct = new File(PATH + File.separatorChar + FN.STRUCT.toString());        File field = new File(PATH + File.separatorChar + FN.FIELD.toString());        File enumEntry = new File(PATH + File.separatorChar                + FN.ENUMENTRY.toString());        File diag = new File(PATH + File.separatorChar + FN.DIAG.toString());        BufferedReader brStruct = new BufferedReader(new FileReader(struct));        BufferedReader brField = new BufferedReader(new FileReader(field));        BufferedReader brEnumEntry = new BufferedReader(new FileReader(                enumEntry));        BufferedReader brDiag = new BufferedReader(new FileReader(diag));        String str;        while ((str = brStruct.readLine()) != null) {            structFileInfo.add(str);        }        while ((str = brField.readLine()) != null) {            fieldFileInfo.add(str);        }        while ((str = brEnumEntry.readLine()) != null) {            enumEntryFileInfo.add(str);        }        while ((str = brDiag.readLine()) != null) {            diagFileInfo.add(str);        }        brStruct.close();        brField.close();        brEnumEntry.close();        brDiag.close();    }    static List<String> diagFileInfo = new ArrayList<String>();    static List<String> structFileInfo = new ArrayList<String>();    static List<String> fieldFileInfo = new ArrayList<String>();    static List<String> enumEntryFileInfo = new ArrayList<String>();    static List<List<String>> structInfoList = new ArrayList<List<String>>();    static final String PATH = "qcn";    static List<Object> searchStruct = new ArrayList<Object>();    static Map<String, Object> NvInfo = new LinkedHashMap<String, Object>();    static final byte[] itemBuf = new byte[2048];    static final boolean DEG = true;    // static final boolean DEG = false;    static boolean checkRecursion = false;    public static void main(String[] args) throws IOException {        efsload load = new efsload();        int init = init(args);        if (init == 0) {            return;        }        String diagIndex = (init == 1) ? ("6^\"" + args[1] + "\"^") : args[1];        String diagInfo = load.initDiag(diagIndex);        // if (DEG)        System.out.println("diagInfo:" + diagInfo);        NvInfo.put("NV/EFS", diagInfo.split("\\^")[2]);        /**********/        String structId = diagInfo.split("\\^")[1].replace("\"", "");        String structIndex = diagInfo.split("\\^")[3] + "^";        load.initStruct(structIndex, new ArrayList<String>(), 1, false);        if (checkRecursion) {            structInfoList.remove(structInfoList.size() - 1);        }        if (structId.equals("71527")) {            List<String> tmpList = new ArrayList(                    structInfoList.get(structInfoList.size() - 1));            structInfoList.clear();            structInfoList.add(tmpList);        }        if (DEG) {            for (List<String> str : structInfoList) {                System.out.println(str);            }        }        int index = 0;        Map<Integer, Object> structMap = new LinkedHashMap<Integer, Object>();        for (List<String> strInfo : structInfoList) {            StringBuffer sb = new StringBuffer();            for (String structInfo : strInfo) {                String argInfo = structInfo.split("\\^")[8];                String fieldInfo = load.initField(structInfo.split("\\^")[3]                        + "^");                if (DEG)                    System.out.println(fieldInfo);                String[] fieldArg = fieldInfo.split("\\^");                String dataType = "i";                String enumId = "";                int intNum = 1;                if (Integer.parseInt(fieldArg[4]) > 8) {                    if (Integer.parseInt(fieldArg[3]) == 0) {                        dataType = "s";                    } else {                        dataType = "e";                        enumId = fieldArg[4];                    }                } else {                    // check the array number.                    String str = structInfo.toString().split("\\^")[7].replace(                            "\"", "");                    intNum = "".equals(str) ? 1 : Integer.parseInt(str);                }                if (intNum <= 1) {                    sb.append(fieldArg[1]).append(":").append(fieldArg[2])                            .append(":").append(dataType).append(":")                            .append(enumId).append(":").append(argInfo)                            .append("^");                } else {                    // for array                    for (int i = 0; i < intNum; i++) {                        sb.append(fieldArg[1] + "[" + i).append("]:")                                .append(fieldArg[2]).append(":")                                .append(dataType).append(":").append(enumId)                                .append("^");                    }                }            }            if (DEG)                System.out.println(sb.toString());            structMap.put(index, sb.toString());            // reset sb            sb.setLength(0);            index++;        }        /*************/        String[] s = diagInfo.split("\\^")[2].split(File.separator);        String efsFile = s[s.length - 1];        load.formateItems(efsFile.subSequence(0, efsFile.length() - 1)                .toString(), structMap);        // nvSearch.formateItems("qp_ims_reg_config1", structMap);        Iterator<?> iterNvInfo = NvInfo.entrySet().iterator();        while (iterNvInfo.hasNext()) {            @SuppressWarnings("rawtypes")            Map.Entry entry = (Map.Entry) iterNvInfo.next();            Object key = entry.getKey();            Object val = entry.getValue();            System.out.println(key + ":\t\t" + val);        }    }    public static int init(String[] args) throws IOException {        if (0 == args.length || "-h".equals(args[0])) {            System.out                    .println("First should add the efs in the tmp mkdir and use the command\n");            System.out                    .println("Usage: efsload <options> <efs file> or <nvid>....\n");            System.out.println("For example:\n");            System.out.println("-h\t\t\t\tdisplay this help.");            System.out.println("-s\t\t\t\treview the code source.");            System.out.println("-i nvid\t\t\t\tload the efs info by nvid.");            System.out.println("       \t\t\t\tfor NV70263, efsload -i 70263");            System.out                    .println("-p file\t\t\t\tload the efs info by file, should load the efs's full path.");            System.out                    .println("       \t\t\t\tfor NV70263, efsload -p '/nv/item_files/ims/qp_ims_ut_config'\n");            System.out.println("Report bugs to sheng.yin@tcl.com\n");            return 0;        }        switch (args[0]) {        case "-s":            File file = new File("src" + File.separatorChar + "efsload.java");            BufferedReader br = new BufferedReader(new FileReader(file));            String str;            while ((str = br.readLine()) != null) {                System.err.println(str);            }            return 0;        case "-i":            return 1;        case "-p":            return 2;        default:            System.err.println("options error");            return 0;        }    }    public String initDiag(String daigIndex) throws IOException {        String strDiag = "";        for (String str : diagFileInfo) {            if (str.contains(daigIndex)) {                strDiag = str;                break;            }        }        return strDiag;    }    //    // public void initStruct(String structIndex, List<String> structList) {    // searchStruct.add(structIndex);    // for (String strStruct : structFileInfo) {    // if (strStruct.startsWith(structIndex)) {    // if (DEG)    // System.out.println(strStruct);    // if ("0".equals(strStruct.split("\\^")[2])) {    // structList.add(strStruct);    // } else {    // String childIndex = strStruct.split("\\^")[3] + "^";    // if (searchStruct.contains(childIndex)) {    // continue;    // } else {    // initStruct(strStruct.split("\\^")[3] + "^", structList);    // }    // }    // }    // }    // structInfoList.add(new ArrayList<String>(structList));    // }    public boolean initStruct(String structIndex, List<String> structList,            int itemNum, boolean isChild) {        searchStruct.add(structIndex);        for (String strStruct : structFileInfo) {            if (strStruct.startsWith(structIndex)) {                if (DEG)                    System.out.println(strStruct);                if ("0".equals(strStruct.split("\\^")[2])) {                    if (!isChild)                        structList.add(strStruct + "^\"\"");                    else {                        structList.add(strStruct + "^[" + itemNum + "]");                    }                } else if("2".equals(strStruct.split("\\^")[2])){                    continue;                }else {                    String childIndex = strStruct.split("\\^")[3] + "^";                    if (searchStruct.contains(childIndex)) {                        continue;                    } else {                        String str = strStruct.split("\\^")[7]                                .replace("\"", "");                        boolean checkNum = Integer.parseInt(strStruct                                .split("\\^")[6]) != 1;                        itemNum = checkNum || "".equals(str) ? 1 : Integer                                .parseInt(str);                        for (int i = 0; i < itemNum; i++) {                            initStruct(strStruct.split("\\^")[3] + "^",                                    structList, i, itemNum != 1 ? true : false);                            checkRecursion = true;                        }                    }                }            }        }        structInfoList.add(new ArrayList<String>(structList));        return checkRecursion;    }    public String initField(String fieldIndex) throws IOException {        String strField = "";        for (String str : fieldFileInfo) {            if (str.startsWith(fieldIndex)) {                strField = str;                break;            }        }        return strField;    }    public String getEnumEntry(String enumEntryIndex) {        String strEnumEntry = "";        for (String str : enumEntryFileInfo) {            if (str.startsWith(enumEntryIndex)) {                strEnumEntry = str.split("\\^")[2];                break;            }        }        return strEnumEntry;    }    public void formateItems(String fileName, Map<Integer, Object> structMap)            throws IOException {        File file = new File("tmp/" + fileName);        if (file.exists()) {            FileInputStream fis = new FileInputStream(file);            DataInputStream dis = new DataInputStream(fis);            int version = 0;            int index = 0;            String[] structList = structMap.get(0).toString().split("\\^");            if (structMap.size() > 1) {                dis.read(itemBuf, 0, 1);                version = new Integer(itemBuf[0]);                structList = structMap.get(version).toString().split("\\^");                NvInfo.put(structList[0].split(":")[0], version);                index = 1;            }            for (; index < structList.length; index++) {                String[] str = structList[index].split(":");                int lenght = Integer.parseInt(str[1]) / 8;                dis.read(itemBuf, 0, lenght);                Object value;                if (str[2].equals("i")) {                    int tmp = new Integer(itemBuf[0]);                    if (tmp < 0) {                        tmp -= 80;                    }                    for (int i = lenght - 1; i > 0; i--) {                        if (new Integer(itemBuf[i]) != 0) {                            if (new Integer(itemBuf[i]) < 0) {                                continue;                            }                            int hexlNum = (int) (Integer.parseInt(Integer                                    .toHexString(itemBuf[i])) << (i + 1));                            tmp += hexlNum * Math.pow(10, i + 1);                            // tmp = tmp | (int) (hexlNum * Math.pow(10, i +                            // 1));                        }                    }                    value = tmp;                } else if (str[2].equals("s")) {                    value = new String(itemBuf, 0, lenght);                } else {                    value = getEnumEntry(str[3] + "^" + new Integer(itemBuf[0]));                }                NvInfo.put(str[0]+str[4], value);            }            dis.close();            fis.close();        }    }}enum FN {    DIAG("Diag.txt"), FIELD("Field.txt"), STRUCT("Struct.txt"), ENUMENTRY(            "EnumEntry.txt");    public String context;    FN(String context) {        this.context = context;    }    public String toString() {        return context;    }}